<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/PrismarineJS/node-minecraft-protocol#readme"

    >minecraft-protocol (v1.1.3)</a>
</h1>
<h4>Parse and serialize minecraft packets, plus authentication and encryption.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.minecraft-protocol">module minecraft-protocol</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.Client">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>Client
            <span class="apidocSignatureSpan">(isServer, version, customPackets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.Server">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>Server
            <span class="apidocSignatureSpan">(version, customPackets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.createClient">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>createClient
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.createDeserializer">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>createDeserializer
            <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.createSerializer">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>createSerializer
            <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.createServer">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>createServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ping">
            function <span class="apidocSignatureSpan">minecraft-protocol.</span>ping
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>browser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>compression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>framing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>serializer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>states</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>supportedVersions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.</span>ursa</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minecraft-protocol.browser">module minecraft-protocol.browser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.browser.Client">
            function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>Client
            <span class="apidocSignatureSpan">(isServer, version, customPackets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.browser.Server">
            function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>Server
            <span class="apidocSignatureSpan">(version, customPackets)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.browser.createDeserializer">
            function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>createDeserializer
            <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.browser.createSerializer">
            function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>createSerializer
            <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>states</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>supportedVersions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minecraft-protocol.compression">module minecraft-protocol.compression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.compression.createCompressor">
            function <span class="apidocSignatureSpan">minecraft-protocol.compression.</span>createCompressor
            <span class="apidocSignatureSpan">(threshold)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.compression.createDecompressor">
            function <span class="apidocSignatureSpan">minecraft-protocol.compression.</span>createDecompressor
            <span class="apidocSignatureSpan">(threshold)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minecraft-protocol.framing">module minecraft-protocol.framing</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.framing.createFramer">
            function <span class="apidocSignatureSpan">minecraft-protocol.framing.</span>createFramer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.framing.createSplitter">
            function <span class="apidocSignatureSpan">minecraft-protocol.framing.</span>createSplitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minecraft-protocol.serializer">module minecraft-protocol.serializer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.serializer.createDeserializer">
            function <span class="apidocSignatureSpan">minecraft-protocol.serializer.</span>createDeserializer
            <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.serializer.createSerializer">
            function <span class="apidocSignatureSpan">minecraft-protocol.serializer.</span>createSerializer
            <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minecraft-protocol.ursa">module minecraft-protocol.ursa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.assertKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>assertKey
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.assertPrivateKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>assertPrivateKey
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.assertPublicKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>assertPublicKey
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.coerceKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>coerceKey
            <span class="apidocSignatureSpan">(orig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.coercePrivateKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>coercePrivateKey
            <span class="apidocSignatureSpan">(orig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.coercePublicKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>coercePublicKey
            <span class="apidocSignatureSpan">(orig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createKey
            <span class="apidocSignatureSpan">(pem, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createPrivateKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPrivateKey
            <span class="apidocSignatureSpan">(pem, password, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createPrivateKeyFromComponents">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPrivateKeyFromComponents
            <span class="apidocSignatureSpan">(modulus, exponent, p, q, dp, dq, inverseQ, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createPublicKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPublicKey
            <span class="apidocSignatureSpan">(pem, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createPublicKeyFromComponents">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPublicKeyFromComponents
            <span class="apidocSignatureSpan">(modulus, exponent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createSigner">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createSigner
            <span class="apidocSignatureSpan">(algorithm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.createVerifier">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createVerifier
            <span class="apidocSignatureSpan">(algorithm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.equalKeys">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>equalKeys
            <span class="apidocSignatureSpan">(key1, key2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.generatePrivateKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>generatePrivateKey
            <span class="apidocSignatureSpan">(modulusBits, exponent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.isKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>isKey
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.isPrivateKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>isPrivateKey
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.isPublicKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>isPublicKey
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.matchingPublicKeys">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>matchingPublicKeys
            <span class="apidocSignatureSpan">(key1, key2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.openSshPublicKey">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>openSshPublicKey
            <span class="apidocSignatureSpan">(key, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minecraft-protocol.ursa.sshFingerprint">
            function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>sshFingerprint
            <span class="apidocSignatureSpan">(sshKey, sshEncoding, outEncoding)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>RSA_NO_PADDING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>RSA_PKCS1_OAEP_PADDING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>RSA_PKCS1_PADDING</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>RSA_PKCS1_SALT_LEN_HLEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>RSA_PKCS1_SALT_LEN_MAX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>RSA_PKCS1_SALT_LEN_RECOVER</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minecraft-protocol" id="apidoc.module.minecraft-protocol">module minecraft-protocol</a></h1>


    <h2>
        <a href="#apidoc.element.minecraft-protocol.Client" id="apidoc.element.minecraft-protocol.Client">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>Client
        <span class="apidocSignatureSpan">(isServer, version, customPackets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Client extends EventEmitter
{
  constructor(isServer, version, customPackets) {
    super();
    this.customPackets=customPackets;
    this.version=version;
    this.isServer = !!isServer;
    this.splitter=framing.createSplitter();
    this.setSerializer(states.HANDSHAKING);
    this.packetsToParse={};
    this.serializer;
    this.compressor=null;
    this.framer=framing.createFramer();
    this.cipher=null;
    this.decipher=null;
    this.decompressor=null;
    this.deserializer;
    this.isServer;
    this.protocolState=states.HANDSHAKING;
    this.ended=true;
    this.latency=0;

    this.on(&#x27;newListener&#x27;, function(event, listener) {
      const direction = this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      if(typeof this.packetsToParse[event] === &#x22;undefined&#x22;) this.packetsToParse[event] = 1;
      else this.packetsToParse[event] += 1;
    });
    this.on(&#x27;removeListener&#x27;, function(event, listener) {
      const direction = this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      this.packetsToParse[event] -= 1;
    });
  }

  get state(){
    return this.protocolState;
  }


  setSerializer(state) {
    this.serializer = createSerializer({ isServer:this.isServer, version:this.version, state: state,customPackets:this.customPackets
});
    this.deserializer = createDeserializer({ isServer:this.isServer, version:this.version, state: state, packetsToParse:
      this.packetsToParse,customPackets:this.customPackets});

    this.splitter.recognizeLegacyPing = state === states.HANDSHAKING;

    this.serializer.on(&#x27;error&#x27;, (e) =&#x3e; {
      let parts;
      if(e.field) {
        parts = e.field.split(&#x22;.&#x22;);
        parts.shift();
      }
      else
        parts=[];
      const serializerDirection = !this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      e.field = [this.protocolState, serializerDirection].concat(parts).join(&#x22;.&#x22;);
      e.message = `Serialization error for ${e.field} : ${e.message}`;
      if(!this.compressor)
        this.serializer.pipe(this.framer);
      else
        this.serializer.pipe(this.compressor);
      this.emit(&#x27;error&#x27;,e);
    });


    this.deserializer.on(&#x27;error&#x27;, (e) =&#x3e; {
      let parts;
      if(e.field) {
        parts = e.field.split(&#x22;.&#x22;);
        parts.shift();
      }
      else
        parts=[];
      const deserializerDirection = this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      e.field = [this.protocolState, deserializerDirection].concat(parts).join(&#x22;.&#x22;);
      e.message = `Deserialization error for ${e.field} : ${e.message}`;
      if(!this.compressor)
        this.splitter.pipe(this.deserializer);
      else
        this.decompressor.pipe(this.deserializer);
      this.emit(&#x27;error&#x27;,e);
    });

    this.deserializer.on(&#x27;data&#x27;, (parsed) =&#x3e; {
      parsed.metadata.name=parsed.data.name;
      parsed.data=parsed.data.params;
      parsed.metadata.state=state;
      debug(&#x22;read packet &#x22; + state + &#x22;.&#x22; + parsed.metadata.name);
      debug(parsed.data);
      this.emit(&#x27;packet&#x27;, parsed.data, parsed.metadata);
      this.emit(parsed.metadata.name, parsed.data, parsed.metadata);
      this.emit(&#x27;raw.&#x27; + parsed.metadata.name, parsed.buffer, parsed.metadata);
      this.emit(&#x27;raw&#x27;, parsed.buffer, parsed.metadata);
    });
  }

  set state(newProperty) {
    const oldProperty = this.protocolState;
    this.protocolState = newProperty;

    if(!this.compressor)
    {
      this.serializer.unpipe(this.framer);
      this.splitter.unpipe(this.deserializer);
    }
    else
    {
      this.serializer.unpipe(this.compressor);
      this.decompressor.unpipe(this.deserializer);
    }

    this.serializer.removeAllListeners();
    this.deserializer.removeAllListeners();
    this.setSerializer(this.protocolState);

    if(!this.compressor)
    {
      this.serializer.pipe(this.framer);
      this.splitter.pipe(this.deserializer);
    }
    else
    {
      this.serializer.pipe(this.compressor);
      this.decompressor.pipe(this.deserializer);
    }

    this.emit(&#x27;state&#x27;, newProperty, oldProperty);
  }

  get compressionThreshold() {
    return this.compressor == null ? -2 : this.compressor.compressionThreshold;
  }

  set c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.Server" id="apidoc.element.minecraft-protocol.Server">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>Server
        <span class="apidocSignatureSpan">(version, customPackets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Server extends EventEmitter
{
  constructor(version, customPackets) {
    super();
    this.version=version;
    this.socketServer=null;
    this.cipher=null;
    this.decipher=null;
    this.clients={};
    this.customPackets=customPackets;
  }

  listen(port, host) {
    const self = this;
    let nextId = 0;
    self.socketServer = net.createServer();
    self.socketServer.on(&#x27;connection&#x27;, socket =&#x3e; {
      const client = new Client(true,this.version,this.customPackets);
      client._end = client.end;
      client.end = function end(endReason) {
        endReason=&#x27;{&#x22;text&#x22;:&#x22;&#x27;+endReason+&#x27;&#x22;}&#x27;;
        if(client.state === states.PLAY) {
          client.write(&#x27;kick_disconnect&#x27;, {reason: endReason});
        } else if(client.state === states.LOGIN) {
          client.write(&#x27;disconnect&#x27;, {reason: endReason});
        }
        client._end(endReason);
      };
      client.id = nextId++;
      self.clients[client.id] = client;
      client.on(&#x27;end&#x27;, function() {
        delete self.clients[client.id];
      });
      client.setSocket(socket);
      self.emit(&#x27;connection&#x27;, client);
    });
    self.socketServer.on(&#x27;error&#x27;, function(err) {
      self.emit(&#x27;error&#x27;, err);
    });
    self.socketServer.on(&#x27;close&#x27;, function() {
      self.emit(&#x27;close&#x27;);
    });
    self.socketServer.on(&#x27;listening&#x27;, function() {
      self.emit(&#x27;listening&#x27;);
    });
    self.socketServer.listen(port, host);
  }

  close() {
    Object.keys(this.clients).forEach(clientId =&#x3e; {
      const client = this.clients[clientId];
      client.end(&#x27;ServerShutdown&#x27;);
    });
    this.socketServer.close();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.createClient" id="apidoc.element.minecraft-protocol.createClient">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>createClient
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createClient(options) {
  assert.ok(options, &#x22;options is required&#x22;);
  assert.ok(options.username, &#x22;username is required&#x22;);

  // TODO: avoid setting default version if autoVersion is enabled
  const optVersion = options.version || require(&#x22;./version&#x22;).defaultVersion;
  const mcData=require(&#x22;minecraft-data&#x22;)(optVersion);
  if (!mcData) throw new Error(`unsupported protocol version: ${optVersion}`);
  const version = mcData.version;
  options.majorVersion = version.majorVersion;
  options.protocolVersion = version.version;

  const client = new Client(false, version.minecraftVersion,options.customPackets);

  tcp_dns(client, options);
  caseCorrect(client, options);
  if (options.version === false) autoVersion(client, options);
  setProtocol(client, options);
  keepalive(client, options);
  encrypt(client, options);
  play(client, options);
  compress(client, options);
  pluginChannels(client, options);

  return client;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

### Echo client example

```js
var mc = require(&#x27;minecraft-protocol&#x27;);
var client = mc.<span class="apidocCodeKeywordSpan">createClient</span>({
host: &#x22;localhost&#x22;,   // optional
port: 25565,         // optional
username: &#x22;email@example.com&#x22;,
password: &#x22;12345678&#x22;,
});
client.on(&#x27;chat&#x27;, function(packet) {
// Listen for chat messages and echo them back.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.createDeserializer" id="apidoc.element.minecraft-protocol.createDeserializer">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>createDeserializer
        <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDeserializer({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})
{
  return new Parser(createProtocol(state,isServer ? &#x22;toServer&#x22; : &#x22;toClient&#x22;,version,customPackets),&#x22;packet&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.createSerializer" id="apidoc.element.minecraft-protocol.createSerializer">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>createSerializer
        <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSerializer({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})
{
  return new Serializer(createProtocol(state,!isServer ? &#x22;toServer&#x22; : &#x22;toClient&#x22;,version,customPackets),&#x22;packet&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.createServer" id="apidoc.element.minecraft-protocol.createServer">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>createServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options) {
  options = options || {};
  const port = options.port != null ?
    options.port :
    options[&#x27;server-port&#x27;] != null ?
      options[&#x27;server-port&#x27;] :
      25565;
  const host = options.host || &#x27;0.0.0.0&#x27;;
  const kickTimeout = options.kickTimeout || 30 * 1000;
  const checkTimeoutInterval = options.checkTimeoutInterval || 4 * 1000;
  const onlineMode = options[&#x27;online-mode&#x27;] == null ? true : options[&#x27;online-mode&#x27;];
  // a function receiving the default status object and the client
  // and returning a modified response object.
  const beforePing = options.beforePing || null;

  const enableKeepAlive = options.keepAlive == null ? true : options.keepAlive;

  const optVersion = options.version || require(&#x22;./version&#x22;).defaultVersion;
  const mcData=require(&#x22;minecraft-data&#x22;)(optVersion);
  const version = mcData.version;

  const serverKey = ursa.generatePrivateKey(1024);

  const server = new Server(version.minecraftVersion,options.customPackets);
  server.motd = options.motd || &#x22;A Minecraft server&#x22;;
  server.maxPlayers = options[&#x27;max-players&#x27;] || 20;
  server.playerCount = 0;
  server.onlineModeExceptions = {};
  server.favicon = options.favicon || undefined;

  server.on(&#x22;connection&#x22;, function(client) {
    client.once(&#x27;set_protocol&#x27;, onHandshake);
    client.once(&#x27;login_start&#x27;, onLogin);
    client.once(&#x27;ping_start&#x27;, onPing);
    client.once(&#x27;legacy_server_list_ping&#x27;, onLegacyPing);
    client.on(&#x27;end&#x27;, onEnd);

    let keepAlive = false;
    let loggedIn = false;
    let lastKeepAlive = null;

    let keepAliveTimer = null;
    let loginKickTimer = setTimeout(kickForNotLoggingIn, kickTimeout);

    let serverId;

    let sendKeepAliveTime;

    function kickForNotLoggingIn() {
      client.end(&#x27;LoginTimeout&#x27;);
    }

    function keepAliveLoop() {
      if(!keepAlive)
        return;

      // check if the last keepAlive was too long ago (kickTimeout)
      const elapsed = new Date() - lastKeepAlive;
      if(elapsed &#x3e; kickTimeout) {
        client.end(&#x27;KeepAliveTimeout&#x27;);
        return;
      }
      sendKeepAliveTime = new Date();
      client.write(&#x27;keep_alive&#x27;, {
        keepAliveId: Math.floor(Math.random() * 2147483648)
      });
    }

    function onKeepAlive() {
      if(sendKeepAliveTime) client.latency = (new Date()) - sendKeepAliveTime;
      lastKeepAlive = new Date();
    }

    function startKeepAlive() {
      keepAlive = true;
      lastKeepAlive = new Date();
      keepAliveTimer = setInterval(keepAliveLoop, checkTimeoutInterval);
      client.on(&#x27;keep_alive&#x27;, onKeepAlive);
    }

    function onEnd() {
      clearInterval(keepAliveTimer);
      clearTimeout(loginKickTimer);
    }

    function onPing() {
      const response = {
        &#x22;version&#x22;: {
          &#x22;name&#x22;: version.minecraftVersion,
          &#x22;protocol&#x22;: version.version
        },
        &#x22;players&#x22;: {
          &#x22;max&#x22;: server.maxPlayers,
          &#x22;online&#x22;: server.playerCount,
          &#x22;sample&#x22;: []
        },
        &#x22;description&#x22;: {&#x22;text&#x22;: server.motd},
        &#x22;favicon&#x22;: server.favicon
      };

      function answerToPing(err, response) {
        if ( err ) return;
        client.write(&#x27;server_info&#x27;, {response: JSON.stringify(response)});
      }

      if(beforePing) {
        if ( beforePing.length &#x3e; 2 ) {
          beforePing(response, client, answerToPing);
        } else {
          answerToPing(null, beforePing(response, client) || response);
        }
      } else {
        answerToPing(null, response);
      }

      client.once(&#x27;ping&#x27;, function(packet) {
        client.write(&#x27;ping&#x27;, {time: packet.time});
        client.end();
      });
    }

    function onLegacyPing(packet) {
      if (packet.payload === 1) {
        const pingVersion = 1;
        sendPingResponse(&#x27;\xa7&#x27; + [pingVersion, version.version, version.minecraftVersion,
            server.motd, server.playerCount.toString(), server.maxPlayers.toString()].join(&#x27;\0&#x27;));
      } else {
        // ping type 0
        sendPingResponse([server.motd, server.playerCount.toString(), server.maxPlayers.toString()].join(&#x27;\xa7&#x27;));
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

If the server is in offline mode, you may leave out the `password` option.

### Hello World server example

```js
var mc = require(&#x27;minecraft-protocol&#x27;);
var server = mc.<span class="apidocCodeKeywordSpan">createServer</span>({
&#x27;online-mode&#x27;: true,   // optional
encryption: true,      // optional
host: &#x27;0.0.0.0&#x27;,       // optional
port: 25565,           // optional
});
server.on(&#x27;login&#x27;, function(client) {
client.write(&#x27;login&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ping" id="apidoc.element.minecraft-protocol.ping">
        function <span class="apidocSignatureSpan">minecraft-protocol.</span>ping
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ping(options, cb) {
  options.host = options.host || &#x27;localhost&#x27;;
  options.port = options.port || 25565;
  const optVersion = options.version || require(&#x22;./version&#x22;).defaultVersion;
  const mcData=require(&#x22;minecraft-data&#x22;)(optVersion);
  const version = mcData.version;
  options.majorVersion = version.majorVersion;
  options.protocolVersion = version.version;

  const client = new Client(false,options.majorVersion);
  client.on(&#x27;error&#x27;, function(err) {
    cb(err);
  });

  client.once(&#x27;server_info&#x27;, function(packet) {
    const data = JSON.parse(packet.response);
    const start = Date.now();
    client.once(&#x27;ping&#x27;, function(packet) {
      data.latency = Date.now() - start;
      cb(null, data);
      client.end();
    });
    client.write(&#x27;ping&#x27;, {time: [0, 0]});
  });

  client.on(&#x27;state&#x27;, function(newState) {
    if(newState === states.STATUS)
      client.write(&#x27;ping_start&#x27;, {});
  });

  // TODO: refactor with src/client/setProtocol.js
  client.on(&#x27;connect&#x27;, function() {
    client.write(&#x27;set_protocol&#x27;, {
      protocolVersion: options.protocolVersion,
      serverHost: options.host,
      serverPort: options.port,
      nextState: 1
    });
    client.state = states.STATUS;
  });

  tcp_dns(client, options);
  options.connect(client);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minecraft-protocol.browser" id="apidoc.module.minecraft-protocol.browser">module minecraft-protocol.browser</a></h1>


    <h2>
        <a href="#apidoc.element.minecraft-protocol.browser.Client" id="apidoc.element.minecraft-protocol.browser.Client">
        function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>Client
        <span class="apidocSignatureSpan">(isServer, version, customPackets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Client extends EventEmitter
{
  constructor(isServer, version, customPackets) {
    super();
    this.customPackets=customPackets;
    this.version=version;
    this.isServer = !!isServer;
    this.splitter=framing.createSplitter();
    this.setSerializer(states.HANDSHAKING);
    this.packetsToParse={};
    this.serializer;
    this.compressor=null;
    this.framer=framing.createFramer();
    this.cipher=null;
    this.decipher=null;
    this.decompressor=null;
    this.deserializer;
    this.isServer;
    this.protocolState=states.HANDSHAKING;
    this.ended=true;
    this.latency=0;

    this.on(&#x27;newListener&#x27;, function(event, listener) {
      const direction = this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      if(typeof this.packetsToParse[event] === &#x22;undefined&#x22;) this.packetsToParse[event] = 1;
      else this.packetsToParse[event] += 1;
    });
    this.on(&#x27;removeListener&#x27;, function(event, listener) {
      const direction = this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      this.packetsToParse[event] -= 1;
    });
  }

  get state(){
    return this.protocolState;
  }


  setSerializer(state) {
    this.serializer = createSerializer({ isServer:this.isServer, version:this.version, state: state,customPackets:this.customPackets
});
    this.deserializer = createDeserializer({ isServer:this.isServer, version:this.version, state: state, packetsToParse:
      this.packetsToParse,customPackets:this.customPackets});

    this.splitter.recognizeLegacyPing = state === states.HANDSHAKING;

    this.serializer.on(&#x27;error&#x27;, (e) =&#x3e; {
      let parts;
      if(e.field) {
        parts = e.field.split(&#x22;.&#x22;);
        parts.shift();
      }
      else
        parts=[];
      const serializerDirection = !this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      e.field = [this.protocolState, serializerDirection].concat(parts).join(&#x22;.&#x22;);
      e.message = `Serialization error for ${e.field} : ${e.message}`;
      if(!this.compressor)
        this.serializer.pipe(this.framer);
      else
        this.serializer.pipe(this.compressor);
      this.emit(&#x27;error&#x27;,e);
    });


    this.deserializer.on(&#x27;error&#x27;, (e) =&#x3e; {
      let parts;
      if(e.field) {
        parts = e.field.split(&#x22;.&#x22;);
        parts.shift();
      }
      else
        parts=[];
      const deserializerDirection = this.isServer ? &#x27;toServer&#x27; : &#x27;toClient&#x27;;
      e.field = [this.protocolState, deserializerDirection].concat(parts).join(&#x22;.&#x22;);
      e.message = `Deserialization error for ${e.field} : ${e.message}`;
      if(!this.compressor)
        this.splitter.pipe(this.deserializer);
      else
        this.decompressor.pipe(this.deserializer);
      this.emit(&#x27;error&#x27;,e);
    });

    this.deserializer.on(&#x27;data&#x27;, (parsed) =&#x3e; {
      parsed.metadata.name=parsed.data.name;
      parsed.data=parsed.data.params;
      parsed.metadata.state=state;
      debug(&#x22;read packet &#x22; + state + &#x22;.&#x22; + parsed.metadata.name);
      debug(parsed.data);
      this.emit(&#x27;packet&#x27;, parsed.data, parsed.metadata);
      this.emit(parsed.metadata.name, parsed.data, parsed.metadata);
      this.emit(&#x27;raw.&#x27; + parsed.metadata.name, parsed.buffer, parsed.metadata);
      this.emit(&#x27;raw&#x27;, parsed.buffer, parsed.metadata);
    });
  }

  set state(newProperty) {
    const oldProperty = this.protocolState;
    this.protocolState = newProperty;

    if(!this.compressor)
    {
      this.serializer.unpipe(this.framer);
      this.splitter.unpipe(this.deserializer);
    }
    else
    {
      this.serializer.unpipe(this.compressor);
      this.decompressor.unpipe(this.deserializer);
    }

    this.serializer.removeAllListeners();
    this.deserializer.removeAllListeners();
    this.setSerializer(this.protocolState);

    if(!this.compressor)
    {
      this.serializer.pipe(this.framer);
      this.splitter.pipe(this.deserializer);
    }
    else
    {
      this.serializer.pipe(this.compressor);
      this.decompressor.pipe(this.deserializer);
    }

    this.emit(&#x27;state&#x27;, newProperty, oldProperty);
  }

  get compressionThreshold() {
    return this.compressor == null ? -2 : this.compressor.compressionThreshold;
  }

  set c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.browser.Server" id="apidoc.element.minecraft-protocol.browser.Server">
        function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>Server
        <span class="apidocSignatureSpan">(version, customPackets)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Server extends EventEmitter
{
  constructor(version, customPackets) {
    super();
    this.version=version;
    this.socketServer=null;
    this.cipher=null;
    this.decipher=null;
    this.clients={};
    this.customPackets=customPackets;
  }

  listen(port, host) {
    const self = this;
    let nextId = 0;
    self.socketServer = net.createServer();
    self.socketServer.on(&#x27;connection&#x27;, socket =&#x3e; {
      const client = new Client(true,this.version,this.customPackets);
      client._end = client.end;
      client.end = function end(endReason) {
        endReason=&#x27;{&#x22;text&#x22;:&#x22;&#x27;+endReason+&#x27;&#x22;}&#x27;;
        if(client.state === states.PLAY) {
          client.write(&#x27;kick_disconnect&#x27;, {reason: endReason});
        } else if(client.state === states.LOGIN) {
          client.write(&#x27;disconnect&#x27;, {reason: endReason});
        }
        client._end(endReason);
      };
      client.id = nextId++;
      self.clients[client.id] = client;
      client.on(&#x27;end&#x27;, function() {
        delete self.clients[client.id];
      });
      client.setSocket(socket);
      self.emit(&#x27;connection&#x27;, client);
    });
    self.socketServer.on(&#x27;error&#x27;, function(err) {
      self.emit(&#x27;error&#x27;, err);
    });
    self.socketServer.on(&#x27;close&#x27;, function() {
      self.emit(&#x27;close&#x27;);
    });
    self.socketServer.on(&#x27;listening&#x27;, function() {
      self.emit(&#x27;listening&#x27;);
    });
    self.socketServer.listen(port, host);
  }

  close() {
    Object.keys(this.clients).forEach(clientId =&#x3e; {
      const client = this.clients[clientId];
      client.end(&#x27;ServerShutdown&#x27;);
    });
    this.socketServer.close();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.browser.createDeserializer" id="apidoc.element.minecraft-protocol.browser.createDeserializer">
        function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>createDeserializer
        <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDeserializer({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})
{
  return new Parser(createProtocol(state,isServer ? &#x22;toServer&#x22; : &#x22;toClient&#x22;,version,customPackets),&#x22;packet&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.browser.createSerializer" id="apidoc.element.minecraft-protocol.browser.createSerializer">
        function <span class="apidocSignatureSpan">minecraft-protocol.browser.</span>createSerializer
        <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSerializer({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})
{
  return new Serializer(createProtocol(state,!isServer ? &#x22;toServer&#x22; : &#x22;toClient&#x22;,version,customPackets),&#x22;packet&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minecraft-protocol.compression" id="apidoc.module.minecraft-protocol.compression">module minecraft-protocol.compression</a></h1>


    <h2>
        <a href="#apidoc.element.minecraft-protocol.compression.createCompressor" id="apidoc.element.minecraft-protocol.compression.createCompressor">
        function <span class="apidocSignatureSpan">minecraft-protocol.compression.</span>createCompressor
        <span class="apidocSignatureSpan">(threshold)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createCompressor = function (threshold) {
  return new Compressor(threshold);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.decipher.on(&#x27;error&#x27;, (err) =&#x3e; this.emit(&#x27;error&#x27;, err));
  this.socket.unpipe(this.splitter);
  this.socket.pipe(this.decipher).pipe(this.splitter);
}

setCompressionThreshold(threshold) {
  if (this.compressor == null) {
    this.compressor = compression.<span class="apidocCodeKeywordSpan">createCompressor</span>(threshold);
    this.compressor.on(&#x27;error&#x27;, (err) =&#x3e; this.emit(&#x27;error&#x27;, err));
    this.serializer.unpipe(this.framer);
    this.serializer.pipe(this.compressor).pipe(this.framer);
    this.decompressor = compression.createDecompressor(threshold);
    this.decompressor.on(&#x27;error&#x27;, (err) =&#x3e; this.emit(&#x27;error&#x27;, err));
    this.splitter.unpipe(this.deserializer);
    this.splitter.pipe(this.decompressor).pipe(this.deserializer);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.compression.createDecompressor" id="apidoc.element.minecraft-protocol.compression.createDecompressor">
        function <span class="apidocSignatureSpan">minecraft-protocol.compression.</span>createDecompressor
        <span class="apidocSignatureSpan">(threshold)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDecompressor = function (threshold) {
  return new Decompressor(threshold);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  setCompressionThreshold(threshold) {
if (this.compressor == null) {
  this.compressor = compression.createCompressor(threshold);
  this.compressor.on(&#x27;error&#x27;, (err) =&#x3e; this.emit(&#x27;error&#x27;, err));
  this.serializer.unpipe(this.framer);
  this.serializer.pipe(this.compressor).pipe(this.framer);
  this.decompressor = compression.<span class="apidocCodeKeywordSpan">createDecompressor</span>(threshold);
  this.decompressor.on(&#x27;error&#x27;, (err) =&#x3e; this.emit(&#x27;error&#x27;, err));
  this.splitter.unpipe(this.deserializer);
  this.splitter.pipe(this.decompressor).pipe(this.deserializer);
} else {
  this.decompressor.threshold = threshold;
  this.compressor.threshold = threshold;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minecraft-protocol.framing" id="apidoc.module.minecraft-protocol.framing">module minecraft-protocol.framing</a></h1>


    <h2>
        <a href="#apidoc.element.minecraft-protocol.framing.createFramer" id="apidoc.element.minecraft-protocol.framing.createFramer">
        function <span class="apidocSignatureSpan">minecraft-protocol.framing.</span>createFramer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFramer = function () {
  return new Framer();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.version=version;
this.isServer = !!isServer;
this.splitter=framing.createSplitter();
this.setSerializer(states.HANDSHAKING);
this.packetsToParse={};
this.serializer;
this.compressor=null;
this.framer=framing.<span class="apidocCodeKeywordSpan">createFramer</span>();
this.cipher=null;
this.decipher=null;
this.decompressor=null;
this.deserializer;
this.isServer;
this.protocolState=states.HANDSHAKING;
this.ended=true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.framing.createSplitter" id="apidoc.element.minecraft-protocol.framing.createSplitter">
        function <span class="apidocSignatureSpan">minecraft-protocol.framing.</span>createSplitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSplitter = function () {
  return new Splitter();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
class Client extends EventEmitter
{
constructor(isServer,version,customPackets) {
  super();
  this.customPackets=customPackets;
  this.version=version;
  this.isServer = !!isServer;
  this.splitter=framing.<span class="apidocCodeKeywordSpan">createSplitter</span>();
  this.setSerializer(states.HANDSHAKING);
  this.packetsToParse={};
  this.serializer;
  this.compressor=null;
  this.framer=framing.createFramer();
  this.cipher=null;
  this.decipher=null;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minecraft-protocol.serializer" id="apidoc.module.minecraft-protocol.serializer">module minecraft-protocol.serializer</a></h1>


    <h2>
        <a href="#apidoc.element.minecraft-protocol.serializer.createDeserializer" id="apidoc.element.minecraft-protocol.serializer.createDeserializer">
        function <span class="apidocSignatureSpan">minecraft-protocol.serializer.</span>createDeserializer
        <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createDeserializer({ state = states.HANDSHAKING, isServer = false, version, customPackets } = {})
{
  return new Parser(createProtocol(state,isServer ? &#x22;toServer&#x22; : &#x22;toClient&#x22;,version,customPackets),&#x22;packet&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.serializer.createSerializer" id="apidoc.element.minecraft-protocol.serializer.createSerializer">
        function <span class="apidocSignatureSpan">minecraft-protocol.serializer.</span>createSerializer
        <span class="apidocSignatureSpan">({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSerializer({ state = states.HANDSHAKING, isServer = false , version, customPackets} = {})
{
  return new Serializer(createProtocol(state,!isServer ? &#x22;toServer&#x22; : &#x22;toClient&#x22;,version,customPackets),&#x22;packet&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minecraft-protocol.ursa" id="apidoc.module.minecraft-protocol.ursa">module minecraft-protocol.ursa</a></h1>


    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.assertKey" id="apidoc.element.minecraft-protocol.ursa.assertKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>assertKey
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assertKey(obj) {
    assert(isKey(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.assertPrivateKey" id="apidoc.element.minecraft-protocol.ursa.assertPrivateKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>assertPrivateKey
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assertPrivateKey(obj) {
    assert(isPrivateKey(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.assertPublicKey" id="apidoc.element.minecraft-protocol.ursa.assertPublicKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>assertPublicKey
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assertPublicKey(obj) {
    assert(isPublicKey(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.coerceKey" id="apidoc.element.minecraft-protocol.ursa.coerceKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>coerceKey
        <span class="apidocSignatureSpan">(orig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coerceKey(orig) {
    if (isKey(orig)) {
        return orig;
    } else if (isStringOrBuffer(orig)) {
        return createKey(orig);
    }

    throw new Error(&#x22;Not a key: &#x22; + orig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.coercePrivateKey" id="apidoc.element.minecraft-protocol.ursa.coercePrivateKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>coercePrivateKey
        <span class="apidocSignatureSpan">(orig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coercePrivateKey(orig) {
    if (isPrivateKey(orig)) {
        return orig;
    } else if (isStringOrBuffer(orig)) {
        return createPrivateKey(orig);
    }

    throw new Error(&#x22;Not a private key: &#x22; + orig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.coercePublicKey" id="apidoc.element.minecraft-protocol.ursa.coercePublicKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>coercePublicKey
        <span class="apidocSignatureSpan">(orig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coercePublicKey(orig) {
    if (isPublicKey(orig)) {
        return orig;
    } else if (isStringOrBuffer(orig)) {
        return createPublicKey(orig);
    }

    throw new Error(&#x22;Not a public key: &#x22; + orig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createKey" id="apidoc.element.minecraft-protocol.ursa.createKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createKey
        <span class="apidocSignatureSpan">(pem, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createKey(pem, encoding) {
    pem = decodeString(pem, encoding);

    if (isPublicKeyPem(pem)) {
        return createPublicKey(pem);
    } else if (isPrivateKeyPem(pem)) {
        return createPrivateKey(pem);
    } else {
        throw new Error(&#x22;Not a key.&#x22;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createPrivateKey" id="apidoc.element.minecraft-protocol.ursa.createPrivateKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPrivateKey
        <span class="apidocSignatureSpan">(pem, password, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPrivateKey(pem, password, encoding) {
    var rsa = new RsaWrap();
    pem = decodeString(pem, encoding);
    password = decodeString(password, encoding);

    try {
        // Note: The native code is sensitive to the actual number of
        // arguments. It&#x27;s *not* okay to pass undefined as a password.
        if (password) {
            rsa.setPrivateKeyPem(pem, password);
        } else {
            rsa.setPrivateKeyPem(pem);
        }
    } catch (ex) {
        if (!isPrivateKeyPem(pem)) {
            throw new Error(&#x22;Not a private key.&#x22;);
        }
        throw ex;
    }

    return PrivateKey(rsa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createPrivateKeyFromComponents" id="apidoc.element.minecraft-protocol.ursa.createPrivateKeyFromComponents">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPrivateKeyFromComponents
        <span class="apidocSignatureSpan">(modulus, exponent, p, q, dp, dq, inverseQ, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPrivateKeyFromComponents(modulus, exponent, p, q, dp, dq, inverseQ, d) {
    var rsa = new RsaWrap();
    rsa.createPrivateKeyFromComponents(modulus, exponent, p, q, dp, dq, inverseQ, d);

    return PrivateKey(rsa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createPublicKey" id="apidoc.element.minecraft-protocol.ursa.createPublicKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPublicKey
        <span class="apidocSignatureSpan">(pem, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPublicKey(pem, encoding) {
    var rsa = new RsaWrap();
    pem = decodeString(pem, encoding);

    try {
        rsa.setPublicKeyPem(pem);
    } catch (ex) {
        if (!isPublicKeyPem(pem)) {
            throw new Error(&#x22;Not a public key.&#x22;);
        }
        throw ex;
    }

    return PublicKey(rsa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  let base64PubKey = mcPubKeyBuffer.toString(&#x27;base64&#x27;);
  const maxLineLength = 65;
  while(base64PubKey.length &#x3e; 0) {
    pem += base64PubKey.substring(0, maxLineLength) + &#x22;\n&#x22;;
    base64PubKey = base64PubKey.substring(maxLineLength);
  }
  pem += &#x22;-----END PUBLIC KEY-----\n&#x22;;
  return ursa.<span class="apidocCodeKeywordSpan">createPublicKey</span>(pem, &#x27;utf8&#x27;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createPublicKeyFromComponents" id="apidoc.element.minecraft-protocol.ursa.createPublicKeyFromComponents">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createPublicKeyFromComponents
        <span class="apidocSignatureSpan">(modulus, exponent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPublicKeyFromComponents(modulus, exponent) {
    var rsa = new RsaWrap();
    rsa.createPublicKeyFromComponents(modulus, exponent);
    return PublicKey(rsa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createSigner" id="apidoc.element.minecraft-protocol.ursa.createSigner">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createSigner
        <span class="apidocSignatureSpan">(algorithm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSigner(algorithm) {
    var hash = crypto.createHash(algorithm);
    var self = {};

    function update(buf, bufEncoding) {
        buf = decodeString(buf, bufEncoding);
        hash.update(buf);
        return self;
    }

    function sign(privateKey, outEncoding) {
        var hashBuf = new Buffer(hash.digest(BINARY), BINARY);
        return privateKey.sign(algorithm, hashBuf, undefined, outEncoding);
    }

    self.sign = sign;
    self.update = update;
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.createVerifier" id="apidoc.element.minecraft-protocol.ursa.createVerifier">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>createVerifier
        <span class="apidocSignatureSpan">(algorithm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createVerifier(algorithm) {
    var hash = crypto.createHash(algorithm);
    var self = {};

    function update(buf, bufEncoding) {
        buf = decodeString(buf, bufEncoding);
        hash.update(buf);
        return self;
    }

    function verify(publicKey, sig, sigEncoding) {
        var hashBuf = new Buffer(hash.digest(BINARY), BINARY);
        sig = decodeString(sig, sigEncoding);
        return publicKey.verify(algorithm, hashBuf, sig);
    }

    self.update = update;
    self.verify = verify;
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.equalKeys" id="apidoc.element.minecraft-protocol.ursa.equalKeys">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>equalKeys
        <span class="apidocSignatureSpan">(key1, key2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equalKeys(key1, key2) {
    // See above for rationale. In this case, there&#x27;s no ssh form for
    // private keys, so we just use PEM for that.

    if (isPrivateKey(key1) &#x26;&#x26; isPrivateKey(key2)) {
        var pem1 = key1.toPrivatePem(UTF8);
        var pem2 = key2.toPrivatePem(UTF8);
        return pem1 === pem2;
    }

    if (isPublicKey(key1) &#x26;&#x26; isPublicKey(key2)) {
        return matchingPublicKeys(key1, key2);
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.generatePrivateKey" id="apidoc.element.minecraft-protocol.ursa.generatePrivateKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>generatePrivateKey
        <span class="apidocSignatureSpan">(modulusBits, exponent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generatePrivateKey(modulusBits, exponent) {
    if (modulusBits === undefined) {
        modulusBits = 2048;
    }

    if (exponent === undefined) {
        exponent = 65537;
    }

    var rsa = new RsaWrap();
    rsa.generatePrivateKey(modulusBits, exponent);

    return PrivateKey(rsa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const enableKeepAlive = options.keepAlive == null ? true : options.keepAlive;

const optVersion = options.version || require(&#x22;./version&#x22;).defaultVersion;
const mcData=require(&#x22;minecraft-data&#x22;)(optVersion);
const version = mcData.version;

const serverKey = ursa.<span class="apidocCodeKeywordSpan">generatePrivateKey</span>(1024);

const server = new Server(version.minecraftVersion,options.customPackets);
server.motd = options.motd || &#x22;A Minecraft server&#x22;;
server.maxPlayers = options[&#x27;max-players&#x27;] || 20;
server.playerCount = 0;
server.onlineModeExceptions = {};
server.favicon = options.favicon || undefined;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.isKey" id="apidoc.element.minecraft-protocol.ursa.isKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>isKey
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isKey(obj) {
    var obj2;

    try {
        var unseal = obj.unseal;
        if (typeof unseal !== &#x22;function&#x22;) {
            return false;
        }
        obj2 = unseal(theUnsealer);
    } catch (ex) {
        // Ignore; can&#x27;t assume that other objects obey any particular
        // unsealing protocol.
        // TODO: Log?
        return false;
    }

    return obj2 !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.isPrivateKey" id="apidoc.element.minecraft-protocol.ursa.isPrivateKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>isPrivateKey
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrivateKey(obj) {
    return isKey(obj) &#x26;&#x26; (obj.decrypt !== undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.isPublicKey" id="apidoc.element.minecraft-protocol.ursa.isPublicKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>isPublicKey
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPublicKey(obj) {
    return isKey(obj) &#x26;&#x26; !isPrivateKey(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.matchingPublicKeys" id="apidoc.element.minecraft-protocol.ursa.matchingPublicKeys">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>matchingPublicKeys
        <span class="apidocSignatureSpan">(key1, key2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matchingPublicKeys(key1, key2) {
    if (!(isKey(key1) &#x26;&#x26; isKey(key2))) {
        return false;
    }

    // This isn&#x27;t the most efficient implementation, but it will suffice:
    // We convert both to ssh form, which has very little leeway for
    // variation, and compare bytes.

    var ssh1 = key1.toPublicSsh(UTF8);
    var ssh2 = key2.toPublicSsh(UTF8);

    return ssh1 === ssh2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.openSshPublicKey" id="apidoc.element.minecraft-protocol.ursa.openSshPublicKey">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>openSshPublicKey
        <span class="apidocSignatureSpan">(key, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function openSshPublicKey(key, encoding) {
    if (!Buffer.isBuffer(key)) {
        key = key.substr(0, 3) === &#x27;ssh&#x27; ? key.split(&#x27; &#x27;)[1] : key;
        key = new Buffer(key, encoding || &#x27;base64&#x27;);
    }

    function parsePublicKey(key) {
        var parts = [],
            partsLength = 3;

        while(key.length) {
            var dLen = key.readInt32BE(0);
            var data = key.slice(4, dLen+4);
            key = key.slice(4+dLen);
            parts.push(data);
            if (!(--partsLength)) break;
        }

        return {
            modulus :   parts[2],
            exponent:   parts[1],
            type    :   parts[0]
        };
    }

    var pubKey = parsePublicKey(key);
    var rsa = new RsaWrap();

    if (pubKey.type != &#x27;ssh-rsa&#x27;) {
        throw new TypeError(&#x27;Only &#x22;ssh-rsa&#x22; format supported&#x27;);
    }

    rsa.openPublicSshKey(pubKey.modulus, pubKey.exponent);

    return PublicKey(rsa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minecraft-protocol.ursa.sshFingerprint" id="apidoc.element.minecraft-protocol.ursa.sshFingerprint">
        function <span class="apidocSignatureSpan">minecraft-protocol.ursa.</span>sshFingerprint
        <span class="apidocSignatureSpan">(sshKey, sshEncoding, outEncoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sshFingerprint(sshKey, sshEncoding, outEncoding) {
    var hash = crypto.createHash(MD5);

    hash.update(decodeString(sshKey, sshEncoding));
    var result = new Buffer(hash.digest(BINARY), BINARY);
    return encodeBuffer(result, outEncoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
